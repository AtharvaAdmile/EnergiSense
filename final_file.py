# -*- coding: utf-8 -*-
"""Final_File.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H3deaiiqv_WrphS679boOIiG-gSdnQTf

# LSTM
"""

import pandas as pd

df_csv = pd.read_csv('/content/energy_data 2.csv')

# Convert 'Timestep' to datetime format
df_csv['Timestamp'] = pd.to_datetime(df_csv['Timestamp'], format='%Y-%m-%d %H:%M:%S')

# Group by hourly Timestampand sum energy consumption
df_hourly_csv = df_csv.groupby(pd.Grouper(key='Timestamp', freq='H')).agg({
    'Energy_Consumption_kWh': 'sum'
}).reset_index()

# Add time features
df_hourly_csv['Hour'] = df_hourly_csv['Timestamp'].dt.hour
df_hourly_csv['DayOfWeek'] = df_hourly_csv['Timestamp'].dt.dayofweek
df_hourly_csv['IsWeekend'] = df_hourly_csv['DayOfWeek'].apply(lambda x: 1 if x >= 5 else 0)

# Preview processed data ready for normalization and LSTM
df_hourly_csv.head()

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Step 1: Normalize energy consumption (0–1 scale)
scaler = MinMaxScaler()
df_hourly_csv['Energy_Norm'] = scaler.fit_transform(df_hourly_csv[['Energy_Consumption_kWh']])

# Step 2: Create sequences for LSTM (past 24 time steps -> next 24 time steps)
sequence_length = 24  # past 24 hours
forecast_horizon = 24  # predict next 24 hours

sequences = []
labels = []

energy_series = df_hourly_csv['Energy_Norm'].values

for i in range(len(energy_series) - sequence_length - forecast_horizon + 1):
    seq = energy_series[i:i+sequence_length]
    label = energy_series[i+sequence_length:i+sequence_length+forecast_horizon]
    sequences.append(seq)
    labels.append(label)

# Convert to numpy arrays and reshape for LSTM
X = np.array(sequences)
y = np.array(labels)
X = X.reshape((X.shape[0], X.shape[1], 1))  # [samples, time steps, features]

# Step 3: Build LSTM model
model = Sequential()
model.add(LSTM(100, activation='relu', input_shape=(sequence_length, 1)))
model.add(Dense(forecast_horizon))  # Output 24 future values
model.compile(optimizer='adam', loss='mse')

# Train the model (increase epochs for better performance with real data)
model.fit(X, y, epochs=20, verbose=1)

# Step 4: Predict next 24 hours energy consumption
# Use the last 24 real data points as input
last_seq = energy_series[-sequence_length:]  # last 24 data points
last_seq = last_seq.reshape((1, sequence_length, 1))

# Predict normalized values for next 24 hours
predicted_norm = model.predict(last_seq)[0]  # shape (24,)

# Inverse transform each predicted value to get kWh
predicted_kWh = scaler.inverse_transform(predicted_norm.reshape(-1, 1)).flatten()

# Fix: Ensure demand is non-negative
predicted_kWh = np.clip(predicted_kWh, 0, None)  # Replace negatives with 0

# Display predicted 24-hour energy consumption
print("Predicted energy consumption for next 24 hours (in kWh):")
for i, val in enumerate(predicted_kWh, start=1):
    print(f"Hour {i}: {val:.3f} kWh")

# Calculate total predicted energy demand
total_kWh = np.sum(predicted_kWh)

# Display result as sentence
print(f"\n\nThe energy demand prediction for the next day is {total_kWh:.2f} kWh.")

np.save('predicted_demand.npy', predicted_kWh)

"""#ConvLSTM"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import ConvLSTM2D, Flatten, Dense, Reshape

# Load synthetic renewable data
df = pd.read_csv('synthetic_renewable_data.csv')

# Features (input) and Targets (output)
features = ['Sunlight_Intensity_Wm2', 'Wind_Speed_mps', 'Cloud_Cover_pct']
targets = ['Solar_Output_kWh', 'Wind_Output_kWh']

# Step 1: Normalize both inputs and outputs
scaler_x = MinMaxScaler()
scaler_y = MinMaxScaler()

X_scaled = scaler_x.fit_transform(df[features])
Y_scaled = scaler_y.fit_transform(df[targets])

# Step 2: Create rolling windows
# Input: Past 30 hours of features
# Output: Next 24 hours of targets
X_train, Y_train = [], []
for i in range(len(df) - 54):  # 30 inputs + 24 outputs = 54 total window
    X_seq = X_scaled[i:i+30]              # Shape: (30, 3)
    Y_seq = Y_scaled[i+30:i+54]           # Shape: (24, 2)
    X_train.append(X_seq)
    Y_train.append(Y_seq)

# Convert to numpy arrays and reshape for ConvLSTM2D
# ConvLSTM2D input shape: (samples, 30, 1, 1, 3) => [time, rows, cols, channels]
X_train = np.array(X_train).reshape(-1, 30, 1, 1, 3)
Y_train = np.array(Y_train).reshape(-1, 24, 2)  # 24 time steps, 2 outputs per step

# Step 3: Build ConvLSTM2D Model
model = Sequential()
model.add(ConvLSTM2D(filters=32, kernel_size=(1,1), input_shape=(30,1,1,3), return_sequences=False))
model.add(Flatten())
model.add(Dense(48))              # 24*2 = 48 outputs flattened
model.add(Reshape((24, 2)))       # Reshape back to (24 hours, 2 outputs)

model.compile(optimizer='adam', loss='mse')
model.fit(X_train, Y_train, epochs=20, verbose=1)

# Step 4: Predict next 24 hours using the last 30 hours of data
X_input = X_scaled[-30:].reshape(1, 30, 1, 1, 3)  # Most recent 30 time steps
forecast_scaled = model.predict(X_input)         # Shape: (1, 24, 2)

# Inverse scale to original kWh values
forecast = scaler_y.inverse_transform(forecast_scaled[0])  # Shape: (24, 2)

# Optional: Display total and hourly values
total_solar = np.sum(forecast[:, 0])
total_wind = np.sum(forecast[:, 1])

print(f"\nForecasted Renewable Output for Next Day (24 hours):")
for i in range(24):
    print(f"Hour {i+1}: Solar = {forecast[i,0]:.2f} kWh, Wind = {forecast[i,1]:.2f} kWh")

print(f"\nTotal Solar Generation = {total_solar:.2f} kWh")
print(f"Total Wind Generation  = {total_wind:.2f} kWh")

np.save('solar_forecast.npy', forecast[:,0])
np.save('wind_forecast.npy', forecast[:,1])

"""# RL"""

import numpy as np
import random
import matplotlib.pyplot as plt

# ---- Predicted Inputs from Previous Models ----
predicted_demand = np.clip(predicted_kWh, 0, None)  # Fix negative demand
solar_forecast = forecast[:, 0]
wind_forecast = forecast[:, 1]

# ---- RL Setup ----
actions = ['UseSolarWind', 'ChargeBattery', 'DelayLoad', 'DischargeBattery', 'UseGrid']
Q_table = {}

def get_level(value, thresholds):
    if value < thresholds[0]:
        return 'Low'
    elif value < thresholds[1]:
        return 'Medium'
    else:
        return 'High'

def reward_function(action, demand, solar, wind, battery, price):
    reward = 0
    total_renewable = solar + wind
    cost = 0

    if action == 'UseSolarWind':
        if total_renewable >= demand:
            reward += 12  # Fully renewable
        else:
            grid_usage = demand - total_renewable
            reward += max(0, 10 - grid_usage * price / 2)  # Dynamic reward
            cost += grid_usage * price

    elif action == 'ChargeBattery':
        if total_renewable > demand:
            reward += 12  # Increased reward for smart charging
        else:
            reward -= 5  # Inefficient charge

    elif action == 'DelayLoad':
        reward += 4
        reward -= 1  # Discomfort penalty

    elif action == 'DischargeBattery':
        if battery >= demand:
            reward += 6
        else:
            reward -= 3

    elif action == 'UseGrid':
        cost += demand * price
        reward -= 5  # Penalty for grid usage

    return reward, cost

# ---- Learning Parameters ----
battery_level = 50  # Starting battery level %
price_list = np.random.uniform(5, 15, 24)
alpha = 0.1  # Learning rate
gamma = 0.9  # Discount factor
epsilon = 0.1  # Exploration rate

# ---- Logs for Visualization ----
cost_log = []
reward_log = []
action_log = []

# ---- RL Simulation for 24 hours ----
for hour in range(24):
    demand = predicted_demand[hour]
    solar = solar_forecast[hour]
    wind = wind_forecast[hour]
    price = price_list[hour]
    total_renewable = solar + wind

    # Discretize state
    demand_level = get_level(demand, [3, 7])
    solar_level = get_level(solar, [3, 7])
    wind_level = get_level(wind, [3, 7])
    battery_level_label = get_level(battery_level, [30, 70])
    price_level = get_level(price, [8, 12])

    state = (hour, demand_level, solar_level, wind_level, battery_level_label, price_level)

    if state not in Q_table:
        Q_table[state] = {a: 0 for a in actions}

    # Epsilon-greedy action selection
    if random.uniform(0, 1) < epsilon:
        action = random.choice(actions)
    else:
        action = max(Q_table[state], key=Q_table[state].get)

    # Take action, get reward and cost
    reward, cost = reward_function(action, demand, solar, wind, battery_level, price)

    # Battery logic with updated demand after discharge
    if action == 'ChargeBattery':
        excess_energy = total_renewable - demand
        if excess_energy > 0:
            charge = excess_energy * 10
            battery_level = min(100, battery_level + charge)

    elif action == 'DischargeBattery':
        if battery_level > 0:
            discharge = min(battery_level / 10, demand)
            battery_level -= discharge * 10
            demand -= discharge  # Reduce demand served by battery

    # Log results
    cost_log.append(cost)
    reward_log.append(reward)
    action_log.append(action)

    # Q-learning update
    current_Q = Q_table[state][action]

    # Estimate future reward
    if hour < 23:
        next_demand = predicted_demand[hour + 1]
        next_solar = solar_forecast[hour + 1]
        next_wind = wind_forecast[hour + 1]
        next_price = price_list[hour + 1]
        next_battery_level = battery_level  # Approximate

        next_state = (
            hour + 1,
            get_level(next_demand, [3, 7]),
            get_level(next_solar, [3, 7]),
            get_level(next_wind, [3, 7]),
            get_level(next_battery_level, [30, 70]),
            get_level(next_price, [8, 12])
        )

        if next_state not in Q_table:
            Q_table[next_state] = {a: 0 for a in actions}

        max_future_Q = max(Q_table[next_state].values())
    else:
        max_future_Q = 0

    # Q update rule
    new_Q = current_Q + alpha * (reward + gamma * max_future_Q - current_Q)
    Q_table[state][action] = new_Q

    # Print log
    print(f"Hour {hour}: {action}, Demand={demand:.2f}, Solar={solar:.2f}, Wind={wind:.2f}, Battery={battery_level:.1f}%, Price={price:.2f}, Reward={reward:.2f}, Cost={cost:.2f}")

# ---- Visualize Results ----
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(cost_log, label='Cost')
plt.title('Hourly Energy Cost')
plt.xlabel('Hour')
plt.ylabel('Cost (₹)')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(reward_log, label='Reward', color='green')
plt.title('Hourly Reward')
plt.xlabel('Hour')
plt.ylabel('Reward')
plt.legend()

plt.tight_layout()
plt.show()